今天我偶然刷到了一篇文章，“华为二面：一个文件里面有5亿个数据，一行一个，没有重复的，进行排序”。不知道又是哪个无良媒体瞎起的标题，夺人眼球。

不过说归说，这题听着就很高大上，5亿个数据排序，想想就很爽。常用的内排序算法有很多，比如我们熟悉的冒泡排序、插入排序、快速排序等等。所谓内排序，意思就是在内存里进行排序，不需要占用外存。

对于内部排序算法，在数据量比较小的情况下，还是可以玩玩的，但像上面说的，5亿个数据，先不说时间要多少，来算算需要多少空间存储这些数据 5 * 10 ^ 8 * 32 =  (1.6 * 10 ^ 10)bit = (1.6 * 10 ^ 10) / (1024 * 1024 * 8) = 1920M = 1.875G，快接近2G了，面试官就是这么坏，他只给你1G的内存，那玩个毛啊，内存都不够，连数据都装不下，何来排序。

这时候就有必要学习一下位图法（BitMap）了。

### 1、什么是位图算法

#### 1.1 基本思想

BitMap的核心思想就是用一个bit位来记录0和1两种状态，将具体数据映射到比特数组的具体某一位上，这个bit位设置为0表示该数不存在，设置为1表示该数存在。由于BitMap使用bit来记录数据，所以大大节省了存储空间，比如上面5亿个数据，如果使用bit来记录，只需要(1.875 / 32)G内存即可。

利用这个特性，**BitMap可以用来处理大量数据的排序、查询以及去重等，BitMap在用户群做交集和并集运算的时候也有极大的便利**。

举个栗子，比如对于数列[2, 3, 6, 4, 1]，在BitMap里是如何存储的呢？

（1）先申请1字节(8 bit)的空间，这样就可以表示8个数，下标范围从0 ~ 7。

（2）然后根据数列将对应的bit位进行设置。对于2，则把下标为2的bit设置为1，依次类推，最终结果如下

![image-20210609231218233](从一道高大上的面试题来学习位图算法.assets/image-20210609231218233.png)

这样如果我们需要得到有序数组的话，只需要从下标0开始遍历，如果bit位的值为1，则把下标输出，即可得到有序数列。

那如果数据很大呢？比如50，那0 ~ 7的下标肯定不够，这时候就需要扩充了，算起来好像需要8个这样的bit数组才行，50应该存放在第8个bit数组下标为0的地方。那中间岂不是还剩下6个空着没用？这是后面要讨论的问题了。注意：即使你只需要用到一个bit，也要至少申请8个bit，这是为了内存对齐。

#### 1.2 Map映射

从上面的介绍可以知道，BitMap的思想还是挺简单的，关键就是如何确定10进制到2进制的关系映射图。因为你可以用int(32bit)或者long(64bit)来进行映射。

如果使用int进行映射，假设我们要排序的数有N个，那么需要申请的内存空间大小就是int[N / 32 + 1]，映射关系如下：

a[0]：0 ~ 31

a[1]：32 ~ 63

a[2]：64 ~ 95

.......

#### 1.3 数据和下标的转换

搞定了数据结构，接下来就是怎么把数据转换到我们申请的bit数组中。我们用“三步走”战略

（1）**确定数据在对应数组a中的下标**

十进制数0 - 31，对应于数组元素a[0]，十进制数32 - 63在数组元素a[1]中，所以可以很容易的知道，一个数num在数组a[num / 32]中，即下标为num / 32。

（2）**确定数据在对应数字a[i]中的下标**

十进制数1在a[0]的下标为1，十进制数31在a[0]中下标为31，十进制数32在a[1]中下标为0。 在十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数num可以通过模32求得在对应数组a[i]中的下标 num % 32。

（3）**存放**

经过上面两步，我们知道一个数num存放在a[num / 32]的num % 32下标上。我可以通过移位操作将对应位置1

a[n >> 5] |= 1 << (n & 0x1F)

n >> 5不用多解释，大家都会，n & 0x1F 保留n的后五位，相当于 n % 32。

#### 1.4 实现一个简单的BitMap



### 2、JDK中的BitSet

