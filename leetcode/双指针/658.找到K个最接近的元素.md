#### 658. 找到 K 个最接近的元素

#### 2022-08-25 LeetCode每日一题

链接：https://leetcode.cn/problems/find-k-closest-elements/

标签：**数组、双指针、二分查找、排序、堆**

> 题目

给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。

整数 a 比整数 b 更接近 x 需要满足：

- |a - x| < |b - x| 或者
- |a - x| == |b - x| 且 a < b


示例 1：

```java
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
```

示例 2：

```java
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
```


提示：

- 1 <= k <= arr.length
- 1 <= arr.length <= 10 ^ 4
- arr 按 升序 排列
- -10 ^ 4 <= arr[i], x <= 10 ^ 4

> 分析

从数组中找k个最靠近x的数，相当于从数组中去掉距离x最远的一些数，最后剩下k个数。因为数组是递增的，所有可以想到使用双指针，从左边两边开始，分别计算到x的距离，然后距离更大的丢弃掉即可，最后剩下的k个数就是答案。

> 编码

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> res = new ArrayList<>();
        int left = 0, right = arr.length - 1;
        for (int i = 0; i < arr.length - k; i++) {
            if (Math.abs(x - arr[left]) <= Math.abs(arr[right] - x)) {
                right--;
            } else {
                left++;
            }
        }

        for (int i = left; i <= right; i++) {
            res.add(arr[i]);
        }

        return res;
    }
}
```

![image-20220825223549475](658.找到K个最接近的元素.assets/image-20220825223549475-1438150.png)

```go
func findClosestElements(arr []int, k int, x int) []int {
    left := 0
    right := len(arr) - 1
    for i:= 0; i < len(arr) - k; i++ {
        if math.Abs((float64)(arr[left] - x)) <= math.Abs((float64)(arr[right] - x)) {
            right--
        } else {
            left++
        }
    }

    return arr[left:right + 1]
}
```

![image-20220825224559362](658.找到K个最接近的元素.assets/image-20220825224559362-1438760.png)