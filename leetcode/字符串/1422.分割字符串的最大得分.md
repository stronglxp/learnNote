#### 1422. 分割字符串的最大得分

链接：https://leetcode.cn/problems/maximum-score-after-splitting-a-string/

标签：**字符串**

> 题目

给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。

「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。

示例 1：

```java
输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3
```

示例 2：

```java
输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5
```

示例 3：

```java
输入：s = "1111"
输出：3
```


提示：

- 2 <= s.length <= 500
- 字符串 s 仅由字符 '0' 和 '1' 组成。

> 分析

可以先统计出字符串中0的总个数（或者1的总个数）sum，然后遍历字符串，假设当前下标为i，[0, i]中0的个数为left，则(i, len)中1的个数为len - i - 1 - (sum - left)。然后和当前最大值比较，取最大值即可。

注意要分割成两个非空字符串，所以遍历不能遍历到字符串末尾，需要留一个字符。

> 编码

```java
class Solution {
    public int maxScore(String s) {
        int zeroNum = 0;
        char[] chs = s.toCharArray();
        for (char c : chs) {
            if (c == '0') {
                zeroNum++;
            }
        }

        int curZeroNum = 0, max = 0, len = chs.length;
        // 到len - 1为止，因为左右必须非空
        for (int i = 0; i < len - 1; i++) {
            if (chs[i] == '0') {
                curZeroNum++;
            }
            // (i, len)中1的数量
            int rightOneNum = len - i - 1 - (zeroNum - curZeroNum);
            max = Math.max(max, curZeroNum + rightOneNum);
        }

        return max;
    }
}
```

![image-20220813100921341](1422.分割字符串的最大得分.assets/image-20220813100921341-0356562.png)