#### 1707. 与数组中元素的最大异或值

#### 2021-05-23 LeetCode每日一题

链接：https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/

标签：**数组、异或、字典树**

> 题目

给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。

第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] <= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。

返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。

```java
输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出：[3,3,7]
解释：
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.

输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
输出：[15,-1,5]
    
1 <= nums.length, queries.length <= 10e5
queries[i].length == 2
0 <= nums[j], xi, mi <= 10e9
```

> 分析

这题如果用暴力的话，很容易就能写出来，就是会超时。

```java
class Solution {
    public int[] maximizeXor(int[] nums, int[][] queries) {
        int[] res = new int[queries.length];

        for (int i = 0; i < queries.length; i++) {
            int a = queries[i][0], b = queries[i][1], max = -1;
            for (int j = 0; j < nums.length; j++) {
                int temp = a;
                if (nums[j] <= b && ((temp ^ nums[j]) > max)) {
                    max = (temp ^ nums[j]);
                }
            }

            res[i] = max;
        }

        return res;
    }
}
```

![image-20210523221739089](1707.与数组中元素的最大异或值.assets/image-20210523221739089.png)

时间复杂度是O(10e10)