#### 851. 喧闹和富有

#### 2021-12-15 LeetCode每日一题

链接：https://leetcode-cn.com/problems/loud-and-rich/

标签：**广度优先搜索、拓扑排序、图、数组**

> 题目

有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。

给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。

现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。

示例 1：

```java
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。
answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），
最安静（有较低安静值 quiet[x]）的人是 person 7。
其他的答案也可以用类似的推理来解释。
```

示例 2：

```java
输入：richer = [], quiet = [0]
输出：[0]
```

提示：

- n == quiet.length
- 1 <= n <= 500
- 0 <= quiet[i] < nquiet 的所有值 互不相同
- 0 <= richer.length <= n * (n - 1) / 2
- 0 <= ai, bi < n
- ai != bi
- richer 中的所有数对 互不相同
- 对 richer 的观察在逻辑上是一致的

> 分析

richer数组可以转换成一幅有向图，[1, 0]即表示1 -> 0。此时1的出度为1，0的入度为1。对于入度为0的节点，则说明没有比该节点更有钱的节点。

可以把入度为0的节点加入队列，每次从队列中取出节点，遍历所有以该节点指向的其他节点，然后再比较quiet的值，如果更小则进行替换。

入度为0的节点是不可能再次加入队列的。

> 编码

```java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        // 每个对象的入度
        int[] in = new int[quiet.length];
        // 对象与对象之间的关系，graph[1][2] = 1说明person1 -> person2，即person1比person2有钱
        int[][] graph = new int[quiet.length][quiet.length];
        // ans[i] = j表示personj的钱不少于personi并且最安静
        int[] ans = new int[quiet.length];

        for (int[] arr : richer) {
            graph[arr[0]][arr[1]] = 1;
            // person arr[1]的入度增加1
            in[arr[1]]++;
        }

        // 存放入度为0的节点
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < quiet.length; i++) {
            // 初始化每个person的答案都是自己
            ans[i] = i;
            // 如果person i的入度为0，说明除了他自己没有谁比他更有钱
            if (in[i] == 0) {
                queue.offer(i);
            }
        }

        while (!queue.isEmpty()) {
            int index = queue.poll();
            for (int i = 0; i < quiet.length; i++) {
                // index -> i，person index比person i有钱
                if (graph[index][i] == 1) {
                    // ans[i]指向ans[index]
                    if (quiet[ans[index]] < quiet[ans[i]]) {
                        ans[i] = ans[index];
                    }
                    // i的入度减1，如果为0，则加入队列
                    if (--in[i] == 0) {
                        queue.offer(i);
                    }
                }
            }
        }

        return ans;
    }
}
```

![image-20211215224240791](851.喧闹和富有.assets/image-20211215224240791.png)