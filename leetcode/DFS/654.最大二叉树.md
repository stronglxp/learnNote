#### 654. 最大二叉树

#### 2022-08-20 LeetCode每日一题

链接：https://leetcode.cn/problems/maximum-binary-tree/

标签：**栈、树、数组、分治、二叉树、单调栈**

> 题目

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

- 创建一个根节点，其值为 nums 中的最大值。
- 递归地在最大值 左边 的 子数组前缀上 构建左子树。
- 递归地在最大值 右边 的 子数组后缀上 构建右子树。

返回 nums 构建的 最大二叉树 。

示例 1：

![img](654.最大二叉树.assets/tree1.jpg)

```java
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：

- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
  - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
    - 空数组，无子节点。
    - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
      - 空数组，无子节点。
      - 只有一个元素，所以子节点是一个值为 1 的节点。
  - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
    - 只有一个元素，所以子节点是一个值为 0 的节点。
    - 空数组，无子节点。
```

示例 2：

![img](654.最大二叉树.assets/tree2.jpg)

```java
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```


提示：

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000
- nums 中的所有整数 互不相同

> 分析

使用DFS，假设当前子数组最左边下标为l，最右边下标为r：

- 当l > r时，说明当前子数组不存在元素了，返回null。
- 找出数组中最大的数num及对应的下标index，构建一个节点node。
- 将数组分成[l, index - 1]和[index + 1, r]，分别作为node节点的左子树和右子树，重复上面两步。

> 编码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return dfs(nums, 0, nums.length - 1);
    }

    private TreeNode dfs(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }
        int index = findMaxNumIndex(nums, start, end);
        TreeNode root = new TreeNode(nums[index]);
        root.left = dfs(nums, start, index - 1);
        root.right = dfs(nums, index + 1, end);
        return root;
    }

    private int findMaxNumIndex(int[] nums, int start, int end) {
        int max = nums[start], index = start;
        for (int i = start + 1; i <= end; i++) {
            if (nums[i] > max) {
                max = nums[i];
                index = i;
            }
        }
        return index;
    }
}
```

![image-20220820092524954](654.最大二叉树.assets/image-20220820092524954-0958726.png)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func constructMaximumBinaryTree(nums []int) *TreeNode {
    var dfs func([]int) *TreeNode
    dfs = func(nums []int) *TreeNode {
        if len(nums) == 0 {
            return nil
        }
        index := 0
        for i, num := range nums {
            if num > nums[index] {
                index = i
            }
        }

        node := TreeNode{nums[index], dfs(nums[:index]), dfs(nums[index + 1:])}
        return &node
    }

    return dfs(nums)
}
```

![image-20220820100236574](654.最大二叉树.assets/image-20220820100236574-0960958.png)